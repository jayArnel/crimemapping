%*******************************************************************************
%*********************************** Fourth Chapter *****************************
%*******************************************************************************

\chapter{Methodology}  %Title of the Fourth Chapter


%********************************** %First Section  **************************************
\section{Application Development}
    The application was developed using Django, a Python-based Web framework. More specifically, the application is built atop GeoDjango, a module in Django that turns it into multi-featured GIS Web framework. This allows the creation and manipulation of spatially-enabled data especially that the application is dealing with city boundaries, crime locations and grids.

    The application's database backend is PostGIS, a kind of PostgreSQL database for geospatial data. This is the most recommended database backend for GIS applications has the best compatibility and support for GeoDjango.

    Through the features and functionalities provided by GeoDjango and PostGIS, we can handle criminal records, city boundaries and grids with ease. They can be represented as geometry objects such as points and polygons that we can easily create, store and fetch from the database using standard Python conventions. These geometry objects are wrapped with methods for handling coordinates, topology, projections and relations with other geometry objects. In the case of our application, a criminal record has an attribute that contains a point, representing the location (latitude, longitude) where the incident happened. This point contains a method that can check if it is on a given cell of a grid, which is represented by a polygon object.

\section{Datasets}
    \subsection{City Boundaries}
        The data for the boundaries of Chicago City was downloaded from data.cityofchicago.org, the city's official data portal hosted by Socrata. The downloaded file is of zip format containing the different shape files representing the data for the city boundaries. The data was imported to the database via GeoDjango's LayerMapping data import utility. The boundary of Chicago city are saved in the database as a CityBorder model instance.
    \subsection{Criminal Records}
        The criminal records of the Chicago is from their dataset that is also on data.cityofchicago.org. The dataset can be accessed using Socrata. The criminal records were fetched and saved in the database via sodapy, a package that binds Socrata with Python. These records are represented by the CriminalRecord model.

\section{Generating the Grid}
    The map grid is created using GeoDjango methods. GeoDjango's geometry objects, such as Polygon and Point, are wrapped with the GEOS (Geometry Engine - Open Source) API. The GEOS API implements SQL spatial functions and operators that allows us to create geometry objects and perform operations and comparisons between location, area and length of objects. However, GeoDjango lacks the support for geodetic functions to deal with distances with respect to the spherical nature of the Earth. Distances cannot be handled linearly and the curvature of the Earth must be taken into consideration. To support this, a library of Geopy will be used.

    The grid is represented by a list of boxes with dimension based on the given size. To create the grid, the NorthWest point of the city boundary is obtained by wrapping the city boundary in the smallest box that can fit the whole city and getting the coordinate of the top-left vertex of the box. This will be the starting point in generating the grid. A square box will be created by calculating the other vertices of the box with the dimension based on the given grid size. The box will only be included to the grid's list when it intersects the boundary of the city. The starting point for the next box will be the top-right corner of the previous box. This will continue until a whole row is completed. The next box will then be generated in the next row. This process is repeated until the whole city area is covered. The list of boxes which represents the grid will be saved in a pickle file so that the grid will be easily fetched next time instead of having to perform the caculations again.

\section{Data Collection and Preprocessing}
    The input data for our learning model is a sequence of periodic snapshots by week, month or year of the presence or absence of a crime type per grid. A row of data has the same number of entries as the number of cells in the grid. For each cell in the grid, CriminalRecord objects are fetched and filtered as to which records happened within the boundaries of that cell for the given crime type. If no crime type is given, all types of crime will be considered. If there is a crime in that cell, the corresponding index in the row of data will have 1. If none, -1 will be entered. So, a row of data is a series of 1 or -1 that corresponds to the presence or absence of a crime type in each grid. This will be repeated for each year, month or week. So the final data is a 2-dimensional array of different months, years or weeks, each of which has a row of data for each grid.

\section{Model}
    The learning model used is built using a library called Keras because it implements the original LSTM proposed by Hochreiter. The input of the model is the sequence of periodic snapshots of the states of each cell in the crid. It is divided into training and validation sets with 0.7 ratio. The model contains a layer of LSTM cells, one for each input in the data. The model's training will be done through 1000 epochs.

\section{Performance Metrics}
    To measure and evaluate the performance of the model, several performance metrics is implemented. The Mean Square of Errors (MSE) is used to measure the precision of the models output value to the target values. Accuracy and F1 Score values is used to measure the accuracy of the model when predicting the next state of the cells in the grid.
